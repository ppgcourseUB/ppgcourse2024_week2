# Population Genomics and Adaptation

Instructor: **Sebastian E. Ramos-Onsins**

Date: July 5th 2024

# *First Session*

## The Dynamics of a Beneficial Selective Process

In the first part of the practical session we will simulate three different selective sweep processes using a forward-in-time evolutionary simulator called *Slim*. 

The objectives of this first part of the practical session are:

* To familiarize with the forward-simulator *Slim*. Understanding how it works and be able to construct your own code.
* Run different scenarios containing a neutral or considering positive selection.
* Visualize the dynamics of the mutations.
* Visualize the patterns of variability across the genome.

## Get Scripts for this session

First of all, localize the scripts and the manual for this practical session. You can obtain it in the github of the course. that is:

```
ghget https://github.com/ppgcourseUB/ppgcourse2024_week2/edit/main/PopGenomicsAdaptation.SebastianERamosOnsins
```

and from here, go to the folder PopGenomicsAdaptation:

```
cd PopGenomicsAdaptation.SebastianERamosOnsins
```

## Forward Simulator: *Slim*

1.	We will simulate a number of different scenarios using [*Slim*](https://messerlab.org/slim/) (Messer, Genetics 2013, Haller and Messer, MBE 2017, Haller and Messer, [MBE 2019](https://academic.oup.com/mbe/article/36/3/632/5229931?login=true), [Am. Nat. 2023](https://www.journals.uchicago.edu/doi/10.1086/723601)). Slim is a forward simulator that allows to simulate many selective positions at the same time in complex demographic patterns. Slim has a **graphical interface** (we will see an example on the practical class) but to speed up the simulation analysis we will use the **command line** program in the practical session. 
2. The simulator contains an extended manual and many "recipes" or examples for many different uses, including complex metapopulation models in spatial context, non-Wright-Fischer models and also is able to work with phenotypic traits and QTLs in relation to the genotypes. 
3. The simulator is designed in a very versatile way, allows to include new functions, debugging code and controling variable using *Eidos* environment. *Slim* also can output trees, genomes, mutations and substitutions at any step in the simulation.

If your computer allows it, download [*Slim*](https://messerlab.org/slim/). Start the graphical interface application and open the initial recipe 4.1 - A basic neutral simulation. Understand the basic commands included. 

*Slim* simulator needs of a file with instructions detailing the events that will be occurring and the time the simulation will take. A *slim* script is inccluded in the folder ("**sweeps\_ind\_vcf.slim**"). The first step need to define a block called *Initialize()*, where parameters and other values are defined prior to start the simulation. Here it is defined the mutation and the recombination rate per position, the type of mutation used (named "m1", with dominance 0.5 and a fixed selective value of s=0 (neutral)). and the genomic element where the mutations appear (the mutation "m1" is included in a genomic element named "g1", which here contains 1e5 positions). We also define the populatin size (4000 diploid individuals) using the command *defineConstant*.

```
initialize() {
	initializeMutationRate(2e-7);
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, 99999);
	initializeRecombinationRate(1e-7);
	
	defineConstant("Ne",4000); //8K chromosomes 
	
	if (exists("slimgui")) {
		defineConstant("freq_sel_init",0.00125);
		defineConstant("freq_sel_end",1.0);
		defineConstant("s_beneficial",0.05);
		defineConstant("ind_sample_size",50);
		defineConstant("file_output1","./slim.test_selsweep.output_file.ms");
	}
	writeFile(filePath=file_output1+"_curve.txt",contents=(""),append=F);
}
```
In the second part of the block *Initialize*, we include new parameters inside a conditional bracket (this conditional will be only active when the **Slim GUI interface** is operative, which is useful for debugging errors) such as the ouptut filename (file\_output1), the sample size collected when the simulation is finished (ind\_sample\_size) but also other parameters that will be necessary to define a selective sweep (the initial and the final frequency of a positive mutation and the strength of this selective position).

Once the parameters for performing the simulation are defined or initialized, the simulation starts following initialy a standard Wright-fisher (WF) evolutionary process: 

1. The generations are non-overlapping and discrete.
2. The probability of an individual being chosen as a parent for a child the next generation is proportional to the individualâ€™s fitness.
3. The individuals are diploid.
4. The offspring are generated by recombination of parental chromosomes with the addition of new mutations. 

```
//do initialization of the population during 20000 generations (5*Ne) to have a population in approximate equlibrium mutation-drift
1 early() { 
	// save this run's identifier, used to save and restore once a positive selected position is lost
	defineConstant("simID", getSeed());
	sim.addSubpop("p1", Ne); 
}
```
The simulation starts at the first generation and continues until achieve 20000 generations (defined in the next step). During this period, the population will be allowed to achieve equilibrium mutation-drift.

Once the simulation is on the generation 20000, a mutation with the defined initial frequency located in the near of the central region changes their selective strength from neutral to positive. The simulation continues until this mutation achieve the final frequency or is lost (a file keeps the frequency of the selected mutation at each generation). In case the mutation is lost, the simulation is re-started from the generation 20000 until the selective mutation achieves the final frequency. 

```
20000 late() {
	if(s_beneficial != 0) {	
		// save the state of the simulation
		sim.outputFull("./tmp_slim_" + simID + ".txt");	
		//look for mutation that is closest to the center
		muts= sim.mutations;
		...
		if (size(dist)) {
			//choose the mutation		
			mutchosen=which(dist==min(dist));
			mut=muts[mutchosen];	
			//add beneficial selection
			mut.setSelectionCoeff(s_beneficial); 
			pos_mut = mut.id; //look at the variant in the total variants
			print("position: " + mut.position + " frequency: " +  sim.mutationFrequencies(p1, mut));
			writeFile(filePath=file_output1+"_curve.txt",contents=("position: "+ mut.position),append=T);
		}
		...
}
```

Once the positive mutation achieves the final frequency, a sample from the population is collected and saved in VCF format.

```
//finish simulation if selective position achieve final frequency, otherwise repeat process from equilibrium saved population
20001:25000 late() {	
		...
		if (sim.mutationFrequencies(p1,muts[pos_mut]) >= freq_sel_end) {	
			print("freq_end = " + sim.mutationFrequencies(p1,muts[pos_mut]));
			writeFile(filePath=file_output1+"_curve.txt",contents=("frequency: " + sim.mutationFrequencies(p1,muts[pos_mut])) ,append=T);
			cat("ACHIEVED\n");
			//writeFile(filePath=file_output1+"_curve.txt",contents=("ACHIEVED: 0"),append=T);
			//print the sampled genomes
			g = p1.sampleIndividuals(ind_sample_size).genomes;
			g.outputVCF(filePath=file_output1+".VCF");
			//sim.outputFull();
			print("Simulation finished");
			//finish simulation
			system("rm ./tmp_slim_" + simID + ".txt");
			sim.simulationFinished();
		}	
		...
}
```

## Run Three different Selective Sweeps Scenarios

Here, we will simulate different selective scenarios in order to see the effect of positive selection on the genome variability. Three different selective sweep scenarios plus a neutral scenarios are defined in the script **"0.run\_slim\_selecting\_sweep.sh" (in the folder ./Practical_1**):

```
# Neutral:
slim -t -m -d "freq_sel_init=0.000125" -d "freq_sel_end=1.0" -d "s_beneficial=0" -d "ind_sample_size=50" -d "file_output1='./00.slim.snm.practical1.output'" ./sweeps_ind_vcf.slim
# Complete Sweep:
slim -t -m -d "freq_sel_init=0.000125" -d "freq_sel_end=1.0" -d "s_beneficial=0.05" -d "ind_sample_size=50" -d "file_output1='./01.slim.selsweep.practical1.output'" ./sweeps_ind_vcf.slim
# Incomplete Sweep:
slim -t -m -d "freq_sel_init=0.000125" -d "freq_sel_end=0.75" -d "s_beneficial=0.05" -d "ind_sample_size=50" -d "file_output1='./02.slim.incomplete_selsweep.practical1.output'" ./sweeps_ind_vcf.slim
# Sweep from Standing variation:
slim -t -m -d "freq_sel_init=0.25" -d "freq_sel_end=1.0" -d "s_beneficial=0.05" -d "ind_sample_size=50" -d "file_output1='./03.slim.standing_selsweep.practical1.output'" ./sweeps_ind_vcf.slim

#plot selective trajectory
R --vanilla < ./run_curve_selection.R

#plot sliding windows heterozigosity
R --vanilla < ./run_sliding_windows_pi.R
```

Each simulation defines the initial and final frequency of a selected position and the strength of the selective effect; the complete sweep starts from frequency 1/8000 and finish at frequency 1.0, the incomplete sweep strats from 1/8000 up to 0.75 and the standing sweep starts from 0.25 up to 1.0. Run simulations doing "**sh 0.run\_slim\_selecting\_sweep.sh**"

Evaluation of the selective models is performed by looking at the frequency trajectory using the R script "**run\_curve\_selection.R**" and by estimating the heterozygosity in sliding windows of 1000 bp from the VCF file with the script "**run\_sliding\_windows\_pi.R**".

## Expected Results

It is expected that a strong selective variant sweep and hitchhike the mutations located in the near of such position. It is also expected that incomplete sweeps have a minor effect, as well as sweeps from standing mutations.

# *Second Session*

## The Detection of the Proportion of Beneficial Substitutions

In this secoond practical session we will focus on the effect of positive and negative selection present at the whole genome. We will estimate the proportion of beneficial mutations by mean of the ratios of polymorphism and the divergence at functional and neutral positions across the genome (MKT framework). We will simulate three different selective scenarios and will analyze the different observed patterns.

The objectives of the second practical session are:

* Run different three scenarios containing positive and/or negative selection.
* Estimate the proportion of beneficial substitutions 
* Contrast estimates with the real value per scenario.

## Get Scripts for this Session

Go to the *Practical\_2* folder. We will use again the *Slim* forward-in-time simulator to run simulations. 

## Script to perform Simulation including Selective Effects across the Whole Genome

This simulations include a proportion of beneficial and/or detrimental variants in functional regions (simulated in codons, where two of the three positions are considered nonsynonymous). Here, two populations (species) are simulated, one is considered as the outgroup and the the other is the target population.

The simulation starts with a single population until achieving an equilibrium mutation-selection-drift. Then, the population split into two populations and diverge 10Ne generations. One individual from the outgroup and a sample from the target population are collected and the Site Frequency Spectrum (SFS) for synonymous and nonsynonymous positions, plus the divergence, are obtained to infer the proportion of beneficial mutations.

The *slim* script for doing the simulations is called "**slim\_template.slim**".


## Run Simulations under Different Selective Scenarios

Here, we will simulate three different selective scenarios (plus one neutral) in order to evaluate the ability to detect the proportion of beneficial substitutions under the defined conditions.The scenarios are constructed from the script "**0.run\_construct\_slim\_conditions.sh" (in the folder ./Practical_2**). 

```
#### RUN DIFFERENT CONDITIONS. OBTAIN SFS IN SYN AND NONSYN. CALCULATE MKTasymptotic. ####
#### GENERAK CONDITIONS:
#### Two populations: ONE target plus ONE outgroup.
#### 1.The initial population run for 5Ne generations to achieve some equilibrium mutation-selection-drift
#### 2.Include NEGATIVE AND/OR POSITIVE SELECTION
#### 3.Split target and outgroup for 10Ne generations

rm ./run_slim_conditions.sh

#fixed paraneters
Ne=750; L=500000;
ind_sample_size=25;

# CONDITION 0:
#NEUTRAL.
FILEOUT="'./00_slim_SFS_SNM.txt'"
rate_ben=0; s_backg_ben=0;
rate_del=0; s_backg_del=0;

echo slim -t -m -d \"Ne=$Ne\" -d \"L=$L\" -d \"rate_ben=$rate_ben\" -d \"rate_del=$rate_del\" -d \"s_backg_ben=$s_backg_ben\" -d \"s_backg_del=$s_backg_del\" -d \"ind_sample_size=$ind_sample_size\" -d \"file_output1=$FILEOUT\" ./slim_template.slim \& >> ./run_slim_conditions.sh

# CONDITION 1:
#NEGATIVE SELECTION.
FILEOUT="'./01_slim_SFS_NEG.txt'"
rate_ben=0;    s_backg_ben=0;
rate_del=0.85; s_backg_del=-0.005;

echo slim -t -m -d \"Ne=$Ne\" -d \"L=$L\" -d \"rate_ben=$rate_ben\" -d \"rate_del=$rate_del\" -d \"s_backg_ben=$s_backg_ben\" -d \"s_backg_del=$s_backg_del\" -d \"ind_sample_size=$ind_sample_size\" -d \"file_output1=$FILEOUT\" ./slim_template.slim \& >> ./run_slim_conditions.sh

# CONDITION 2:
#BENEFICIAL SELECTION.
FILEOUT="'./02_slim_SFS_POS.txt'"
rate_ben=0.1; s_backg_ben=0.002;
rate_del=0.0; s_backg_del=0;

echo slim -t -m -d \"Ne=$Ne\" -d \"L=$L\" -d \"rate_ben=$rate_ben\" -d \"rate_del=$rate_del\" -d \"s_backg_ben=$s_backg_ben\" -d \"s_backg_del=$s_backg_del\" -d \"ind_sample_size=$ind_sample_size\" -d \"file_output1=$FILEOUT\" ./slim_template.slim \& >> ./run_slim_conditions.sh

# CONDITION 3:
#NEGATIVE SELECTION PLUS BENEFICIAL SELECTION.
FILEOUT="'./03_slim_SFS_NEG_POS.txt'"
rate_ben=0.10; s_backg_ben=+0.002;
rate_del=0.85; s_backg_del=-0.005;

echo slim -t -m -d \"Ne=$Ne\" -d \"L=$L\" -d \"rate_ben=$rate_ben\" -d \"rate_del=$rate_del\" -d \"s_backg_ben=$s_backg_ben\" -d \"s_backg_del=$s_backg_del\" -d \"ind_sample_size=$ind_sample_size\" -d \"file_output1=$FILEOUT\" ./slim_template.slim \& >> ./run_slim_conditions.sh

echo "sh ./run_slim_conditions.sh"
sh ./run_slim_conditions.sh
```

This script creates a new script named "*run\_slim\_conditions.sh*" and run once the file is created. The file execute four simulations at the same time in the computer.

## Results Format

The results will be separated in different files, one for each simulation condition. The files will start with the name "[number]\_slim\_SFS\_\*.txt". You can see the data text using the command *more*, *less*, *cat* or using a text editor such as *nano*.

The results will be the SFS of nonsynonymous and synonymous sites. The nine outputs will be similar to this:

```
SFS	fr1 	fr2 	fr3 	fr4 	fr5 	fr6 	fr7 	fr8 	fr9 	fr10 	fr11 	fr12 	fr13 	fr14 	fr15 	fr16 	fr17 	fr18 	fr19 	fr20 	fr21 	fr22 	fr23 	fr24 	fr25 	fr26 	fr27 	fr28 	fr29 	fr30 	fr31 	fr32 	fr33 	fr34 	fr35 	fr36 	fr37 	fr38 	fr39 	fr40 	fr41 	fr42 	fr43 	fr44 	fr45 	fr46 	fr47 	fr48 	fr49	PosP1	Fixed	PosP2	FixBen
nsyn	321	152	88	72	40	40	28	25	26	32	17	22	23	21	19	12	13	12	16	7	10	19	10	14	9	13	12	14	11	15	6	6	12	6	16	11	10	8	10	12	8	13	11	7	11	12	9	8	8	333333	2743	333333	1064
syn	263	116	79	78	71	35	32	25	42	23	21	20	12	19	15	18	16	11	16	20	12	15	19	7	9	17	6	11	10	7	9	8	10	10	8	2	7	12	12	6	9	4	8	7	6	6	5	5	6	166666	1552	166666	0	
```

## Estimating the proportion of Beneficial Substitutions (alpha) from Simulation Data

The estimation of alpha can be calculated with several methods. We will compare the real value of alpha (real alpha = fixed beneficial substitutions / fixed nonsynonymous substitutions) with other two estimates: the MKT standard alpha (alpha = 1 - Ks/Ps * Pn/Kn) and the asymptotic alpha ([Messer and Petrov 2013](https://www.pnas.org/doi/full/10.1073/pnas.1220835110)). A web version of the asymptotic alpha estimation performed by [Haller and Messer](http://benhaller.com/messerlab/asymptoticMK.html) is available. We will use a R code version performed by Haller and Messer ([Haller and Messer 2017](http://dx.doi.org/10.1534/g3.117.039693)) to estimate the alpha values.

### Estimate alpha using the SFS and Fixations

We will use R code for this step. The code contains the calculation of alpha functions, the definition of arrays to keep the data, performing the results plot and write the tables. 

The R code for estimating alpha is include in the R file **Results\_plotMKT.R**. 

The code reads the data, includes SFS and divergence values in data frames and runs the the asymptotic function. The plots contain the true alpha, the MKT standard alpha and the asymptotic alpha for each condition. Also tables with results are kept for posterior comparison.

To run all the script from command line, do:

```
R --vanilla < ./Results_plotMKT.R
```

## Comparison of Results

Fill the Table with all Results and compare them with the true values. Discuss the results and the plots. You can find the template in the file *table\_results.xlsx*.



